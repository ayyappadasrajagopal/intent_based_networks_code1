clc;
close all;
clear all;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Example usage of intent_to_actions_gemini.m
generate_with_gemini("Rotate servo 90 degrees, wait 40 seconds, then return to 0.");

function generate_with_gemini(prompt)
    % Set your Gemini API Key (get it from AI Studio: https://aistudio.google.com/app/apikey)
    apiKey = getenv("GEMINI_API_KEY");
    if isempty(apiKey)
        error("GEMINI_API_KEY environment variable not set. Run: setx GEMINI_API_KEY ""your_key_here"" ");
    end

    % Gemini endpoint
    url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=" + apiKey;

    % Build request JSON
    data = struct( ...
        "contents", {struct( ...
            "role","user", ...
            "parts", {struct("text", prompt)} ...
        )}, ...
        "generationConfig", struct( ...
            "response_mime_type","application/json" ...
        ) ...
    );

    % Convert to JSON string
    body = jsonencode(data);

    % Web options
    opts = weboptions( ...
        "MediaType","application/json", ...
        "Timeout",60 ...
    );

    % Make the request
    response = webwrite(url, body, opts);

    % Extract candidates
    if isfield(response,"candidates") && ~isempty(response.candidates)
        disp("---- Gemini Response ----");
        disp(response.candidates(1).content.parts(1).text);
    else
        disp("No candidates returned.");
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% % Example raw JSON text from Gemini
% rawText = '{"commands": [{"servo": {"angle": 90, "time": 2000}}, {"servo": {"angle": 0, "time": 0}}, {"servo": {"angle": 45, "time": 1000}}]}';
% 
% % Decode JSON into MATLAB struct
% cmds = jsondecode(rawText);
% 
% % Preallocate arrays
% n = numel(cmds.commands);
% angles = zeros(1,n);
% times  = zeros(1,n);
% 
% % Extract each command
% for k = 1:n
%     angles(k) = cmds.commands(k).servo.angle;
%     times(k)  = cmds.commands(k).servo.time;
% end
% 
% % Show result
% disp("Decoded Servo Commands:");
% table(times(:), angles(:), 'VariableNames', {'Time_ms','Angle_deg'})

% servo_tracking_discrete.m
% Discrete-time state-space servo tracking of JSON commands using LQR + Nbar.
% Copy this file and run in MATLAB.

% clear; close all; clc;

%% === Example JSON (replace rawText with real Gemini output) ===
rawText = '{"commands": [{"servo": {"angle": 180, "time": 40}}]}';

%% === Decode JSON and extract trajectory ===
cmds = jsondecode(rawText);
nCmd = numel(cmds.commands);
angles_deg = zeros(1, nCmd);
dur_ms     = zeros(1, nCmd);

for k = 1:nCmd
    entry = cmds.commands(k).servo;
    angles_deg(k) = double(entry.angle);
    dur_ms(k)     = double(entry.time)*1000;
end
dur_ms(dur_ms <= 0) = 100;  % replace 0 duration with small hold

% Waypoints and desired trajectory
waypoint_t = [0, cumsum(dur_ms)/1000];
waypoint_angles = [0, angles_deg];
dt = 0.01;              
t_final = waypoint_t(end) + 1.0;
t = 0:dt:t_final;
ref_deg = angles_deg.*ones(1,length(t));
ref_rad = deg2rad(ref_deg);

%% === Continuous-time second-order servo model ===
J = 1e-3;     % larger inertia → more realistic
b = 1e-2;     % damping
K_t = 1e-2;   % torque constant

A_c = [0 1; 0 -b/J];
B_c = [0; K_t/J];
C_c = [1 0];
D_c = 0;

sys_c = ss(A_c,B_c,C_c,D_c);
sys_d = c2d(sys_c, dt);
A_d = sys_d.A; B_d = sys_d.B; C_d = sys_d.C;

%% === Augment with integral action for setpoint tracking ===
% x_aug = [x; integral_error]
A_aug = [A_d, zeros(2,1);
         -C_d, 1];
B_aug = [B_d; 0];
Q = diag([50, 1, 200]);  % penalize angle + integral error
R = 1e-2;
K_aug = dlqr(A_aug,B_aug,Q,R);

Kx = K_aug(1:2);
Ki = K_aug(3);

%% === Simulation ===
N = length(t);
x = zeros(2,N);
y = zeros(1,N);
u_hist = zeros(1,N);
intErr = 0;

for k = 1:N-1
    r_k = ref_rad(k);
    y(k) = C_d*x(:,k);
    e = r_k - y(k);
    intErr = intErr + e*dt;
    
    % Control law
    u = -Kx*x(:,k) - Ki*intErr;
    u = max(min(u,5),-5);  % saturation
    u_hist(k) = u;
    
    % Update states
    x(:,k+1) = A_d*x(:,k) + B_d*u;
end
y(N) = C_d*x(:,N);

%% === Convert to degrees ===
y_deg = rad2deg(y);

%% === Plots ===
figure;
subplot(2,1,1);
plot(t, ref_deg,'r--','LineWidth',1.5); hold on;
plot(t, y_deg,'b-','LineWidth',1.8);
xlabel('Time (s)'); ylabel('Angle (deg)');
legend('Desired','Tracked'); grid on;
title('Tracking with Discrete LQR + Integral Action');

subplot(2,1,2);
plot(t,u_hist,'k','LineWidth',1.5);
xlabel('Time (s)'); ylabel('Control input');
title('Control Signal'); grid on;


% ===== Fixed 4-quadrant animation (drop-in block) =====
% Requires variables: t (time vector), y_deg (actual angle deg), ref_deg (desired angle deg)
if ~exist('t','var') || ~exist('y_deg','var') || ~exist('ref_deg','var')
    error('This block requires t, y_deg and ref_deg variables in the workspace.');
end

% rod length (constant radius)
if ~exist('L','var') || isempty(L)
    L = 0.08;  % meters (change if you want)
end

% Create figure with two subplots: top = animation, bottom = angle vs time
fig = figure('Name','Servo: Fixed-Radius Animation + Angle Plot','Units','normalized','Position',[0.1 0.1 0.6 0.7]);
% --- Top: fixed 4-quadrant axes
ax1 = subplot(2,1,1);
hold(ax1,'on');
axis(ax1,'equal');     % keep x and y scaling equal
margin = 0.02;
xlim(ax1,[-L-margin L+margin]);
ylim(ax1,[-L-margin L+margin]);
% draw cross hairs (x=0,y=0)
plot(ax1,[-L-margin L+margin],[0 0],':k','LineWidth',0.8);
plot(ax1,[0 0],[-L-margin L+margin],':k','LineWidth',0.8);
% draw circle showing the constant radius
theta_circ = linspace(0,2*pi,400);
plot(ax1, L*cos(theta_circ), L*sin(theta_circ), 'Color', [0.85 0.85 0.85]);
% pivot dot
plot(ax1,0,0,'ko','MarkerFaceColor','k','MarkerSize',6);
% plot handles for arms (initialize)
hActual  = plot(ax1,[0 L],[0 0],'b-','LineWidth',6,'Color',[0 0.45 0.74]);
hDesired = plot(ax1,[0 L],[0 0],'r--','LineWidth',2);
hText    = text(ax1, -L+0.01, L-0.01, '', 'FontSize',11, 'Interpreter','none');
title(ax1,'Servo Arm (blue = actual, red = desired)');
xlabel(ax1,'X (m)'); ylabel(ax1,'Y (m)');
grid(ax1,'on');

% --- Bottom: angle vs time plot (preplot curves)
ax2 = subplot(2,1,2);
hold(ax2,'on');
hRef = plot(ax2, t, ref_deg, 'r--', 'LineWidth', 1.4);
hOut = plot(ax2, t, y_deg,  'b-',  'LineWidth', 1.6);
% vertical time marker line
yl = ylim(ax2);
hTime = plot(ax2, [t(1) t(1)], yl, 'k--', 'LineWidth', 1.2);
xlabel(ax2,'Time (s)'); ylabel(ax2,'Angle (deg)');
legend(ax2, {'Desired','Actual'}, 'Location','best');
title(ax2,'Angle vs Time');
grid(ax2,'on');
% fix y-limits so they don't autoscale during animation
ymin = min([ref_deg(:); y_deg(:)]); ymax = max([ref_deg(:); y_deg(:)]);
pad = max(5, 0.1*(ymax - ymin));  % at least ±5 deg padding
ylim(ax2, [ymin - pad, ymax + pad]);

% --- Animation loop: update both arms and time marker
dt_est = t(2) - t(1);           % estimated sample step
N = length(t);
playbackSpeed = 1;              % 1 = real-time, >1 faster, <1 slower
frameStep = 1;                  % update every sample (set >1 to skip frames)

for k = 1:frameStep:N
    % actual and desired angles in radians
    thA = deg2rad(y_deg(k));   % actual (tracked)
    thD = deg2rad(ref_deg(k)); % desired (reference)

    % constant-radius endpoints
    xA = L * cos(thA); yA = L * sin(thA);
    xD = L * cos(thD); yD = L * sin(thD);

    % update arm graphics (do NOT replot axes)
    set(hActual,  'XData', [0 xA], 'YData', [0 yA]);
    set(hDesired, 'XData', [0 xD], 'YData', [0 yD]);
    set(hText,    'String', sprintf('t = %.2f s   | Actual = %.1f°   | Desired = %.1f°', ...
        t(k), y_deg(k), ref_deg(k)));

    % update time marker on bottom plot
    set(hTime, 'XData', [t(k) t(k)], 'YData', ylim(ax2));

    drawnow limitrate;

    % pause to roughly match simulation time (adjust playbackSpeed as needed)
    if k + frameStep <= N
        pause( (t(min(k+frameStep,N)) - t(k)) / playbackSpeed );
    end
end

%% === Performance metric ===
err = ref_deg - y_deg;
rmse = sqrt(mean(err.^2));
fprintf('Tracking RMSE = %.3f deg\n', rmse);
